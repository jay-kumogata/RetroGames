# generated by Grok3

import pyxel
import math
from Ball import *

class TennisEngine:
    W = 0
    S = 1
    D = 2
    Up = 3
    Down = 4
    Left = 5

    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.floor_height = height / 3 * 2
        self.fence_height = 20
        self.gravity = 0.5
        self.bounce = 0.6
        self.left_direction = 0
        self.right_direction = -math.pi
        self.left_player = True
        self.right_player = False
        self.wait = True
        self.delay = 30
        self.my_ball = Ball(width / 3, height / 2)  

    def update(self, p_keys):
        if p_keys[self.W]:
            self.left_direction_increment(-2)
        if p_keys[self.S]:
            self.left_direction_increment(2)
        if p_keys[self.D]:
            self.hit_left()
        if p_keys[self.Up]:
            self.right_direction_increment(2)
        if p_keys[self.Down]:
            self.right_direction_increment(-2)
        if p_keys[self.Left]:
            self.hit_right()

        # 角度を制限
        self.right_direction = max(min(self.right_direction, -math.pi / 2), -math.pi * 3 / 2)
        self.left_direction = max(min(self.left_direction, math.pi / 2), -math.pi / 2)

        if self.delay <= 0:
            self.wait = False

        if not self.wait:
            # 重力と床の衝突判定
            if self.my_ball.pos_y >= self.floor_height:
                self.my_ball.set_position(self.my_ball.prev_pos_x, self.my_ball.prev_pos_y)
                self.my_ball.bounce_floor(self.bounce)
            else:
                # ボールの停止判定
                if abs(self.floor_height - self.my_ball.prev_pos_y) > self.gravity / 2:
                    self.my_ball.update(self.gravity)
                else:
                    if self.my_ball.pos_x < self.width / 2:
                        self.reset_ball_left()
                    elif self.my_ball.pos_x > self.width / 2:
                        self.reset_ball_right()

            # 壁の衝突判定
            if self.my_ball.pos_x < 0:
                self.reset_ball_left()
            if self.my_ball.pos_x > self.width:
                self.reset_ball_right()

            # ネットの衝突判定
            if self.fence_collision_detection(self.my_ball):
                self.my_ball.set_position(self.my_ball.prev_pos_x, self.my_ball.prev_pos_y)
                self.my_ball.bounce_fence(self.bounce)

            self.delay = 30
        else:
            self.delay -= 1

    def draw(self):
        # 画面をクリア
        pyxel.cls(1)
        # 背景（半透明でフェード効果を模倣）
        pyxel.rect(0, 0, self.width, self.height, 1)

        # 床の描画
        pyxel.line(40, self.floor_height + 2.5, self.width - 40, self.floor_height + 2.5, 6)

        # ネットの描画
        pyxel.line(self.width / 2, self.floor_height, self.width / 2,
                   self.floor_height - self.fence_height, 6)
        # ボールの描画
        self.my_ball.draw()

        # 左プレイヤーのパドル（回転行列で描画）
        center_x, center_y = self.width / 10, self.height / 10
        radius = self.height / 12
        line_length = self.width / 12
        # 円の描画（円は回転しないのでそのまま）
        pyxel.circ(center_x, center_y, radius, 5)
        # 線の描画（回転を適用）
        line_end_x = center_x + line_length * math.cos(self.left_direction)
        line_end_y = center_y + line_length * math.sin(self.left_direction)
        pyxel.line(center_x, center_y, line_end_x, line_end_y, 14)

        # 右プレイヤーのパドル（回転行列で描画）
        center_x, center_y = self.width / 10 * 9, self.height / 10
        # 円の描画
        pyxel.circ(center_x, center_y, radius, 5)
        # 線の描画（回転を適用）
        line_end_x = center_x + line_length * math.cos(self.right_direction)
        line_end_y = center_y + line_length * math.sin(self.right_direction)
        pyxel.line(center_x, center_y, line_end_x, line_end_y, 14)

    def hit(self):
        self.wait = False
        if abs(self.my_ball.pos_y - self.floor_height) < 0.01:
            self.my_ball.pos_y -= 2
        elif self.left_player and self.my_ball.pos_x < self.width / 2:
            theta = self.left_direction
            right_vector = [math.cos(theta), math.sin(theta)]
            right_vector = [v * 7 for v in right_vector]
            self.my_ball.set_speed(right_vector[0], right_vector[1])
            self.right_player = True
            self.left_player = False
        elif self.my_ball.pos_x > self.width / 2 and self.right_player:
            theta = self.right_direction
            right_vector = [math.cos(theta), math.sin(theta)]
            right_vector = [v * 7 for v in right_vector]
            self.my_ball.set_speed(right_vector[0], right_vector[1])
            self.right_player = False
            self.left_player = True

    def hit_left(self):
        self.wait = False
        if abs(self.my_ball.pos_y - self.floor_height) < 0.01:
            self.my_ball.pos_y -= 2
        elif self.left_player and self.my_ball.pos_x < self.width / 2:
            theta = self.left_direction
            right_vector = [math.cos(theta), math.sin(theta)]
            right_vector = [v * 7 for v in right_vector]
            self.my_ball.set_speed(right_vector[0], right_vector[1])
            self.right_player = True
            self.left_player = False

    def hit_right(self):
        self.wait = False
        if abs(self.my_ball.pos_y - self.floor_height) < 0.01:
            self.my_ball.pos_y -= 2
        if self.my_ball.pos_x > self.width / 2 and self.right_player:
            theta = self.right_direction
            right_vector = [math.cos(theta), math.sin(theta)]
            right_vector = [v * 7 for v in right_vector]
            self.my_ball.set_speed(right_vector[0], right_vector[1])
            self.right_player = False
            self.left_player = True

    def left_direction_increment(self, p_increment):
        self.left_direction += math.radians(p_increment)

    def right_direction_increment(self, p_increment):
        self.right_direction += math.radians(p_increment)

    def fence_collision_detection(self, p_ball):
        if (p_ball.pos_x >= self.width / 2 and p_ball.prev_pos_x <= self.width / 2) or \
           (p_ball.pos_x <= self.width / 2 and p_ball.prev_pos_x >= self.width / 2):
            if p_ball.prev_pos_y >= self.floor_height - self.fence_height or \
               p_ball.pos_y >= self.floor_height - self.fence_height:
                return True
        return False

    def reset_ball_left(self):
        self.my_ball.set_position(self.width * 3 / 4, self.height / 2)
        self.my_ball.set_prev_position(0, self.height / 2)
        self.my_ball.set_speed(0, 0)
        self.wait = True
        self.right_player = True
        self.left_player = False

    def reset_ball_right(self):
        self.my_ball.set_position(self.width / 4, self.height / 2)
        self.my_ball.set_prev_position(self.width, self.height / 2)
        self.my_ball.set_speed(0, 0)
        self.wait = True
        self.right_player = False
        self.left_player = True

# End of TennisEngine.py        
